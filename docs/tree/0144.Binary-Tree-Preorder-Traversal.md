---
title: 0144. Binary Tree Preorder Traversal
sidebarDepth: 3
---

# 144. Binary Tree Preorder Traversal

## Description

Given a binary tree, return the preorder traversal of its nodes' values.

**Example:**

```txt
Input:Â [1,null,2,3]
   1
    \
     2
    /
   3

Output:Â [1,2,3]
```

Follow up: Recursive solution is trivial, could you do it iteratively?
 
**Links**

[(en)https://leetcode.com/problems/binary-tree-preorder-traversal/](https://leetcode.com/problems/binary-tree-preorder-traversal/)
<br />
[(ä¸­æ–‡)https://leetcode-cn.com/problems/binary-tree-preorder-traversal/](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

## Solutions

### Solution 1

é€’å½’æ–¹å¼ï¼Œéå¸¸å®¹æ˜“ç†è§£ã€‚

```java

/**
 * Recursive way.
 * */
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    helper(root, res);
    return res;
}
private void helper(TreeNode root, List<Integer> res) {
    if (root == null) return;
    res.add(root.val);
    helper(root.left, res);
    helper(root.right, res);
}
```

### Solution 2

ä½¿ç”¨è¿­ä»£æ–¹å¼æ¥è§£å†³ï¼Œå³ä½¿ç”¨æ ˆ ``stack`` æ¥è¾…åŠ©ã€‚åŸç†å¾ˆç®€å•ï¼Œå°±æ˜¯æŠŠåè®¿é—®çš„èŠ‚ç‚¹å…ˆæ”¾å…¥æ ˆä¸­ä¿å­˜ã€‚

ä¾‹å¦‚: 

```txt
    A
   /  \ 
  B    C
 å…ˆå°† A push è¿›æ ˆï¼Œå½“æ ˆä¸ä¸ºç©º (!stack.isEmpty()):
    1. ä»æ ˆä¸­ pop å‡ºèŠ‚ç‚¹ poped; 
    2. å¦‚æœ poped (pop å‡ºæ¥çš„èŠ‚ç‚¹) å³å­©å­ä¸ä¸º null, å°†å®ƒ push è¿›æ ˆ
    3. å¦‚æœ poped çš„å·¦å­©å­ä¸ä¸º null, å°†å®ƒ push è¿›æ ˆ
```

```java
/**
preOrder traversal iteration way using a stack.
*/
public List<Integer> preorderTraversal(TreeNode root) {
    if (root == null) return new ArrayList<>();
    List<Integer> result = new ArrayList<>();
    
    Deque<TreeNode> stack = new ArrayDeque<>();
    stack.push(root);
    TreeNode poped = null;
    while (!stack.isEmpty()) {
        poped = stack.pop();
        result.add(poped.val);
        if (poped.right != null)
            stack.push(poped.right);
        if (poped.left != null)
            stack.push(poped.left);
    }
    return result;
}
```

### Solution 3

è¿­ä»£æ–¹å¼çš„è§£æ³•ï¼Œé™¤äº†ä¸Šé¢ä½¿ç”¨æ ˆçš„æ–¹å¼å¤–ï¼Œè¿˜æœ‰å®Œå…¨ä¸ä½¿ç”¨æ ˆçš„æ–¹æ³•ã€‚

::: tip Info
è¯¥æ–¹æ³•æ˜¯æˆ‘ä¹‹å‰åœ¨ geeksforgeeks å­¦ä¹  inorder traversal æ—¶ï¼Œäº†è§£åˆ°æœ‰ä¸€ç§ä¸ä½¿ç”¨æ ˆæ¥è§£å†³ä¸­æ ¹éå†çš„æ–¹å¼ï¼Œä¹‹åä½¿ç”¨ç›¸ä¼¼çš„æ€è·¯ï¼Œè‡ªå·±ç¼–ç¨‹å®ç°çš„ã€‚
æœ¬æ–‡åªç»™å‡º ``preorder`` éå†æ–¹å¼ã€‚
:::

æ€è·¯:

ä»¤ ``curr`` æŒ‡å‘å½“å‰æ ¹èŠ‚ç‚¹ ``root``, å½“ ``curr != null``:
1. å› ä¸ºæ˜¯å…ˆæ ¹éå†ï¼Œæ‰€ä»¥ç›´æ¥è®¿é—®å½“å‰èŠ‚ç‚¹å€¼ ``curr.val``;
2. å¦‚æœ ``curr`` çš„å·¦å­©å­ä¸ºç©º (``curr.left == null``)ï¼Œç›´æ¥ä»¤ ``curr = curr.right``;
3. å¦åˆ™(else), ä»¤ ``curr`` çš„å³å­æ ‘åš ``curr``å·¦å­©å­çš„å³å­æ ‘çš„æœ€å³èŠ‚ç‚¹çš„å³å­©å­ï¼Œç„¶å ``curr = curr.left``ã€‚

```txt
    A
   /  \ 
  B    C
      /
     D

è®¿é—®å®Œ A ä¹‹åï¼Œæ ‘å˜æˆ -> 
        A
       /
      B 
        \
         C
        /
       D
...
```

::: warning NOTICE
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äºä¸ä½¿ç”¨æ ˆæ¥å­˜æ”¾åç»­è®¿é—®çš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥åªèƒ½å¯¹æ ‘çš„ç»“æ„è¿›è¡Œä¿®æ”¹ã€‚
æ‰€ä»¥æ­¤è§£æ³•åªé€‚åˆå…è®¸å¯¹è¾“å…¥çš„æ ‘è¿›è¡Œä¿®æ”¹çš„æƒ…å†µã€‚
:::

```java
/**
 * preorder traversal without using stacks.
 * Complexity Analysis: 
 *  Time complexity: O(n) while n is the number of the nodes in binary tree.
 *  Space complexity: O(1) if result array does not counts
 * */
public List<Integer> preorderTraversal(TreeNode root) { 
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;
    TreeNode curr = root;
    TreeNode pre = null;
    while (curr != null) {
        res.add(curr.val);
        if (curr.left == null) {
            curr = curr.right;
        } else { // make curr's right childs as the right child of the rightmost chld of curr's left child
            pre = curr.left;
            if (curr.right != null) {
                while (pre.right != null)
                    pre = pre.right;
                pre.right = curr.right;
                curr.right = null;
            }
            // navigate to curr's left child
            curr = curr.left;
        }
    }
}
```

## Summary

äºŒå‰æ ‘çš„éå†ï¼Œå¤§è‡´ä¸ºä¸º Breath-First Traversal ï¼ˆå¹¿åº¦ä¼˜å…ˆéå†ï¼‰: levelOrderTraversal, ä»¥åŠ Depth-First Traversal ï¼ˆæ·±åº¦ä¼˜å…ˆéå†ï¼‰: preoderTraveersal, inorderTraversal, postorderTraversalã€‚

å¯¹äºæ·±åº¦éå†ä¼˜å…ˆçš„ä¸‰ç§æ–¹å¼ï¼Œä½¿ç”¨é€’å½’çš„è§£å†³æ–¹æ¡ˆæ˜¯éå¸¸ç›´è§‚æ˜“æ‡‚çš„ï¼Œè€Œå¯¹äºéé€’å½’æ–¹å¼ï¼Œå¤§å¤šéƒ½ä½¿ç”¨æ ˆæ¥è¾…åŠ©å®ç°ï¼Œæ‰€ä»¥å½“æˆ‘æ‰¾åˆ°ä¸€ç§ä¸ä½¿ç”¨æ ˆï¼Œæ›´å¿«çš„æ–¹å¼æ—¶ï¼Œçœ‹åˆ° Accept ä¹‹åï¼Œæ˜¯ 0 ms, beats 100%, çœŸçš„æœ‰ä¸€ç§æˆå°±æ„Ÿã€‚ğŸ˜
